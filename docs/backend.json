{
  "entities": {
    "DiaryEntry": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DiaryEntry",
      "type": "object",
      "description": "Represents a single diary entry.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the DiaryEntry entity."
        },
        "title": {
          "type": "string",
          "description": "Title of the diary entry."
        },
        "content": {
          "type": "string",
          "description": "Content of the diary entry, stored as rich text."
        },
        "dateCreated": {
          "type": "string",
          "description": "Date and time when the diary entry was created.",
          "format": "date-time"
        },
        "dateModified": {
          "type": "string",
          "description": "Date and time when the diary entry was last modified.",
          "format": "date-time"
        },
        "categoryIds": {
          "type": "array",
          "description": "References to Categories. (Relationship: Category N:N DiaryEntry)",
          "items": {
            "type": "string"
          }
        },
        "tagIds": {
          "type": "array",
          "description": "References to Tags. (Relationship: Tag N:N DiaryEntry)",
          "items": {
            "type": "string"
          }
        },
        "mood": {
          "type": "string",
          "description": "The users mood associated with the journal entry"
        },
        "weather": {
          "type": "string",
          "description": "The weather associated with the journal entry"
        },
        "imageUrl": {
            "type": "string",
            "description": "URL of an image associated with the entry."
        }
      },
      "required": [
        "id",
        "title",
        "content",
        "dateCreated",
        "dateModified"
      ]
    },
    "Category": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Category",
      "type": "object",
      "description": "Represents a category to classify diary entries.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Category entity."
        },
        "name": {
          "type": "string",
          "description": "Name of the category (e.g., 'Work', 'Travel')."
        },
        "description": {
          "type": "string",
          "description": "Description of the category."
        }
      },
      "required": [
        "id",
        "name"
      ]
    },
    "Tag": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Tag",
      "type": "object",
      "description": "Represents a tag to further classify diary entries.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Tag entity."
        },
        "name": {
          "type": "string",
          "description": "Name of the tag."
        }
      },
      "required": [
        "id",
        "name"
      ]
    },
    "AppUser": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AppUser",
      "type": "object",
      "description": "Represents a user of the diary application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the AppUser entity."
        },
        "email": {
          "type": "string",
          "description": "Email address of the user.",
          "format": "email"
        }
      },
      "required": [
        "id",
        "email"
      ]
    },
    "PasswordResetRequest": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PasswordResetRequest",
      "type": "object",
      "description": "Represents a password reset request.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the PasswordResetRequest entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to AppUser. (Relationship: AppUser 1:N PasswordResetRequest)"
        },
        "resetToken": {
          "type": "string",
          "description": "The reset token."
        },
        "expirationDate": {
          "type": "string",
          "description": "The expiration date and time for the reset token.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "resetToken",
        "expirationDate"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "AppUser",
          "schema": {
            "$ref": "#/backend/entities/AppUser"
          },
          "description": "Stores user profiles. Secured by checking if request.auth.uid == userId.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/diaryEntries/{diaryEntryId}",
        "definition": {
          "entityName": "DiaryEntry",
          "schema": {
            "$ref": "#/backend/entities/DiaryEntry"
          },
          "description": "Stores diary entries for each user. The userId in the path ensures only the authenticated user can access their entries.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "diaryEntryId",
              "description": "The unique identifier for the diary entry."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/categories/{categoryId}",
        "definition": {
          "entityName": "Category",
          "schema": {
            "$ref": "#/backend/entities/Category"
          },
          "description": "Categories are private to each user and stored under their respective document.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "categoryId",
              "description": "The unique identifier for the category."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/tags/{tagId}",
        "definition": {
          "entityName": "Tag",
          "schema": {
            "$ref": "#/backend/entities/Tag"
          },
          "description": "Tags are private to each user and stored under their respective document.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "tagId",
              "description": "The unique identifier for the tag."
            }
          ]
        }
      },
      {
        "path": "/password_reset_requests/{passwordResetRequestId}",
        "definition": {
          "entityName": "PasswordResetRequest",
          "schema": {
            "$ref": "#/backend/entities/PasswordResetRequest"
          },
          "description": "Stores password reset requests. Relies on checking the userId in the document against the authenticated user to verify ownership before allowing a password reset.",
          "params": [
            {
              "name": "passwordResetRequestId",
              "description": "The unique identifier for the password reset request."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to ensure security, scalability, and ease of debugging, following the principles of Authorization Independence, Clarity of Intent, DBAC (Database-Based Access Control), and QAPs (Rules are not Filters). Authorization Independence is achieved through denormalization, specifically by storing user-related data within the user's document or subcollections. Structural Segregation is maintained by grouping data with similar access requirements into dedicated collections. Access Modeling uses path-based ownership for user-owned data and membership maps for collaborative data (although collaborative features are not present in the current feature set). Global roles are managed through existence checks in dedicated collections. The design also emphasizes data clarity with explicit state modeling and consistent naming conventions.\n\nThe structure employs the following:\n\n1.  **Users Collection (`/users/{userId}`):** Stores user profiles. This collection is secured by checking if `request.auth.uid == userId`.\n2.  **Diary Entries Collection (`/users/{userId}/diaryEntries/{diaryEntryId}`):** Stores diary entries for each user. The `userId` in the path ensures only the authenticated user can access their entries.  The structure enables list operations since entries are secured by path-based ownership.\n3.  **Categories Collection (`/users/{userId}/categories/{categoryId}`):** Categories are private to each user and stored under their respective document.\n4.  **Tags Collection (`/users/{userId}/tags/{tagId}`):** Tags are private to each user and stored under their respective document.\n5.  **Password Reset Requests Collection (`/password_reset_requests/{passwordResetRequestId}`):** Stores password reset requests. This uses a flat collection to manage requests without hierarchical dependencies. It relies on checking the `userId` in the document against the authenticated user to verify ownership before allowing a password reset.  This approach is simpler and more secure than using subcollections when handling sensitive operations like password resets.\n\nThis structure ensures that access control is straightforward and efficient, reducing the need for complex rules. Each collection's security rules can be independently defined, minimizing the risk of unintended access and simplifies debugging."
  }
}
    